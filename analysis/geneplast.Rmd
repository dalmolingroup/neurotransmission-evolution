---
title: "Geneplast"
knit: neurotransmissionevolution::custom_knit
---
a
```{r message=FALSE, include=FALSE}
knitr::opts_chunk$set(
  warning     = FALSE,
  message     = FALSE#,
  # cache       = TRUE,
  # cache.extra = file.mtime("download/link_pathway_entrez.tsv")
)
library(tidyverse)
library(magrittr)
library(geneplast)
library(ape)
library(XML)
library(rentrez)
library(neurotransmissionevolution)
```
b
```{r}
data(
  cogs,
  cogs_of_interest,
  string_eukaryotes,
  package = "neurotransmissionevolution"
)

phyloTree <- read.tree("../data/hybrid_tree_modified.nwk")
```

Some minor data formatting is done before feeding it to geneplast
```{r}
# formating cogdata column names for geneplast
cogs %<>% rename(protein_id = string_id, ssp_id = taxid) %>% select(protein_id, ssp_id, cog_id)

# adding species names to taxid tree
phyloTree %<>% list_modify(
  tip.alias = string_eukaryotes %$% string_name[match(phyloTree[["tip.label"]], taxid)]
)
```

### Geneplast
Geneplast's groot.preprocess function structures an `ogr` object which the `groot` will perform the rooting on.
We then retrieve the numeric root (`groot.get("results")`) for the `cogs_of_interest`, that is, orthologous groups pertaining to neurotransmission genes.
```{r echo=T, results="hide"}
ogr <- groot.preprocess(
  cogdata   = cogs,
  phyloTree = phyloTree,
  spid      = "9606",
  cogids    = cogs_of_interest %>% pull(cog_id) %>% unique
)

roots <- groot(ogr, nPermutations = 1) %>%
  groot.get("results") %>%
  rownames_to_column("cog_id") %>%
  select(cog_id, root = Root)

write_tsv(roots, "geneplast_roots.tsv")
```


#### Clade names
Each root branches to a clade that diverged from humans some time in the past. It is nice to have these clades taxonomically named to ease our interpretation. Unlike NCBI Taxonomy, TimeTree's internal nodes are not named. Therefore, we query the NCBI Taxonomy API to try to find most clade names automatically. It is important to note that we are using a hybrid tree primarily built from TimeTree data. This means NCBI Taxonomy naming will not perfectly match clades in our tree. For instance, root #36 branches to a clade containing 38 species from the SAR supergroup, but also 1 species from the Haptista rank, namely _Emiliania huxleyi_. The Haptista group is a sister clade to SAR, so it might be the case that _Emiliania huxleyi_ is actually correctly placed together with SAR species by TimeTree, given their evolutionary proximity. Resolving these naming conflicts is not trivial and falls out of our scope.
```{r}
lineages <- entrez_fetch(
  db      = "taxonomy",
  id      = string_eukaryotes[["new_taxid"]],
  rettype = "xml",
  retmode = "xml",
  parsed  = TRUE
)

string_eukaryotes %<>% mutate(
  root        = ogr@tree$tip.group[taxid],
  lineage_txt = xpathSApply(lineages, "//Lineage", XML::xmlValue)
)
  
roots_names <- string_eukaryotes %>%
  
  # splitting lienage text
  mutate(lineage_split = strsplit(lineage_txt, "; ")) %>%
  group_by(root) %>%
  
  # for each root, get all lineages intersections
  # but also keep complete lineages for future use
  summarise(lineage = Reduce(intersect, lineage_split) %>% list,
            lineage_list = lineage_split %>% list) %>%
  
  # windowed lineage differences (window size = 3 -> curr, next, prev)
  mutate(downstream_diff = mapply(setdiff,         lineage, lead(lineage))) %>%
  mutate(upstream_diff   = mapply(setdiff, downstream_diff,  lag(lineage))) %>%
  
  # defaults to the furthest rank (i.e. the 1st one)
  mutate(clade_name = map_chr(upstream_diff, 1, .default = NA)) %>%
  
  # finding at what rank depth should mixed lineages be collapsed
  mutate(collapse_depth = lineage %>% map_int(length) + 1) %>%
  
  group_by(root) %>%
  # fallback_name is the collapsed lineage ranks
  mutate(fallback_name = lineage_list %>%
           flatten %>%
           map2_chr(collapse_depth, `[`) %>%
           table %>%
           sort(TRUE) %>%
           # names %>%
           { paste0(names(.), " (", .,")") } %>%
           paste0(collapse="; ")) %>%
  mutate(clade_name = coalesce(clade_name, fallback_name)) %>%
  select(root, clade_name)

write_tsv(roots_names, "temp/temp_geneplast_clade_names.tsv")
```

#### Plotting roots
a
```{r message=FALSE, include=FALSE}
library(treeio)
library(ggtree)
library(tidytree)
```
```{r}
long_pam <- ogr@orthoct %>%
  rownames_to_column("ssp_id") %>%
  select(-`9606`) %>%
  pivot_longer(-1, names_to = "cog_id") %>%
  # mutate(value = ifelse(value == 0, NA, 1)) %>%
  filter(value == 1)

pam <- ggplot(long_pam, aes(cog_id, ssp_id, fill = value)) +
  geom_tile() +
  theme(legend.position="none")

tree <- as.ggplot(
  ~{
    phyloTree %>%
    rotatePhyloTree("9606") %>%
    plot.phylo("cladogram", show.tip.label = F, no.margin = T)
  }, 1, vjust = -0.05)

plot.phylo(phyloTree %>% rotatePhyloTree("9606"), "cladogram", no.margin = T)

tree_heatmap <- ogr@orthoct %>%
  as_tibble(rownames = NA) %>%
  select(-1)

phyloTreedata <- phyloTree %>%
  rotatePhyloTree("9606") %>%
  as_tibble %>%
  left_join(string_eukaryotes %>% select(label = taxid, ncbi_name, root)) %>%
  as.treedata

p <- ggtree(phyloTreedata, branch.length = "none", ladderize = F) +
  geom_tiplab(aes(label = ncbi_name), offset = 1, hjust = 0, align = T) +
  xlim(0,300)

gheatmap(
  p,
  tree_heatmap,
  offset=50,
  width=5,
  font.size=2,
  colnames_angle=45,
  hjust=1,
  low = "#DDDDDD",
  high = "#00AA44"
)
```


```{r eval=FALSE, include=FALSE}
setwd("plots/roots/")

groot.plot(ogr, plot.lcas = TRUE, width=10, height=20, cex.lab = 0.2, cex.nodes = 0.4)

setwd("../../")

# for (i in roots$cog_id) {
#   groot.plot(
#     ogr, 
#     whichOG = i, 
#     width=10, 
#     height=20, 
#     cex.lab = 0.2, 
#     cex.nodes = 0.4
#   )
# }
```

